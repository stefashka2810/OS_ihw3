# Пикулева Стефания Дмитриевна, БПИ2310, вариант 16

В гостинице 10 одноместных номеров. Клиенты гостиницы снимают номер на одни или несколько суток (задается при создании клиента). Если в гостинице нет свободных номеров, клиенты не уходят, а устраиваются на рядом с гостиницей на скамейках и ждут в порядке очереди, пока
любой из номеров не освободится (других гостиниц в городе нет).
Создать клиент–серверное приложение, моделирующее работу гостиницы.
Сервер — это гостиница. Прибывающие гости могут порождаться отдельным общим клиентом. Другой клиент — это скамейки, образующие очередь ожидающих гостей.

## 4-5 баллов (folder 4-5 points)

### Сценарий моделирования

* **Гостиница** реализована одним процессом-сервером `server`.
  Сервер держит массив из 10 структур `Room` (каждая — номер) и очередь «скамеек» — связанный список клиентов, которым не хватило мест.
  На каждое входящее TCP-подключение сервер создаёт поток: читает строку `DAYS=N`, пытается сразу выдать свободный номер, а если номеров нет, ставит сокет гостя в очередь.

* **Гость** — это отдельный процесс-клиент `client`. При запуске он подключается к серверу, отправляет желаемое число суток и дальше пассивно ждёт сообщений:

  * `ASSIGNED R` — номер получен, клиент печатает «Got room R».
    Внутри сервера параллельный поток спит `days * DAY_SEC` секунд (масштаб «суток»), затем выселяет гостя.
  * `WAIT` — мест нет; клиент сообщает, что сидит «на скамейке».
  * `CHECKOUT` — номер освобождён, клиент благодарит и выходит.

* **Сутки** сжаты до нескольких секунд (параметр `DAY_SEC` — третий аргумент сервера), чтобы увидеть динамику.

* Каждый компонент выводит **только свои локальные события**.

### Форматы команд

```
./server <bind_ip> <port> [DAY_SEC]
./client <server_ip> <port> <days>
```

* `bind_ip` — интерфейс, на котором слушает сервер (например `127.0.0.1` или `0.0.0.0`).
* `DAY_SEC` — длина «суток» в секундах; по умолчанию 5.
* `<days>` — сколько суток желает конкретный гость.

#### Пример

  ```bash
  # терминал 1 — сервер
  ./server 127.0.0.1 5555 3        # сервер; 1 «сутки» = 3 с

  # терминал 2 — массовый запуск гостей
  for i in $(seq 1 20); do
      days=$((RANDOM%4+1))
      ./client 127.0.0.1 5555 "$days" &
  done
  wait
  ```

### Завершение работы

* **Клиент** закрывает соединение самостоятельно после получения `CHECKOUT` и завершает процесс (`return 0`).
  Если сервер неожиданно упадёт, клиент увидит разрыв TCP и также выйдет.
* **Сервер** останавливается по `Ctrl-C` (сигнал `SIGINT`) или командой `kill -INT <PID>`.
  Главный цикл `accept()` завершается, процесс выходит; остальные потоки завершаются вместе с ним.

## 6-7 баллов (folder 6-7 points)

* В код добавлен центральный журнал событий.
  В сервер встроен модуль `logger.c`, который печатает каждую строку в консоль сервера и рассылает ту же строку всем «монитор-клиентам», подключённым на отдельный TCP-порт `6000`.
* Появилась программа `log_client`. Её можно запустить в любой момент (до, во время или после наплыва гостей) — она мгновенно получает всю текущую историю и «живую» ленту событий.
* Заголовочный файл не нужен: в `server.c` просто объявлены два публичных прототипа `logger_init()` и `logger_log()`, а весь остальной код логгера живёт в `logger.c`.

### Сценарий моделирования

* **Гостиница** — процесс `server`.
  Логика распределения номеров и очереди осталась прежней, но все важные действия сопровождаются вызовом

  ```c
  logger_log("ASSIGN room=%d days=%d queue=%zu", …);
  ```

  поэтому каждая операция попадает в общий журнал.

* **Гость** — процесс `client`, без изменений.

* **Монитор-клиент** — процесс `log_client`.
  После подключения к серверу на порт `6000` он видит строки формата

  ```
  YYYY-MM-DD HH:MM:SS  ТЕКСТ_СОБЫТИЯ
  ```

### Форматы команд

```
./server <bind_ip> <guest_port> [DAY_SEC]    # поднимает также лог-порт 6000
./client <server_ip> <guest_port> <days>     # гость
./log_client <server_ip> 6000                # монитор
```

* `DAY_SEC` — продолжительность «суток» в секундах (по-умолчанию 5).

### Пример

```bash
# терминал 1 — сервер
./server 127.0.0.1 5555 3       # 1 «сутки» = 3 с

# терминал 2 — монитор (можно запустить до или после гостей)
./log_client 127.0.0.1 6000

# терминал 3 — массовый запуск гостей
for i in $(seq 1 20); do
    ./client 127.0.0.1 5555 $((RANDOM%4+1)) &
done
wait
```

Монитор сразу покажет, как первые 10 гостей получают номера, остальные становятся в очередь, затем по мере освобождения комнат очередь сокращается.

### Завершение работы

* **Гости** завершаются сами после `CHECKOUT`.
* **Монитор-клиент** — `Ctrl-C` или просто закрыть окно; сервер автоматически вычистит его из списка при первой неудачной передаче.
* **Сервер** гасится `Ctrl-C` (SIGINT). При этом:

  * поток приёма логгеров прерывается,
  * все клиентские потоки завершаются вместе с процессом,
  * открытые гость-сокеты закрываются ядром.

## 8 баллов (8 points)

 Относительно версии на 6-7 баллов был изменен только файл server.c. 
 Теперь сервер подключает логгер через logger_init и logger_log, логгирование делегировано внешнему модулю logger.c. Логгер сам управляет списком клиентов.

 ### Пример запуска

 ```bash
# терминал 1 - сервер
./server 0.0.0.0 5555 3

# терминал 2 - несколько лог-клиентов 
./log_client 127.0.0.1 6000
./log_client 127.0.0.1 6000

# терминал 3 - гости
for i in {1..20}; do ./client 127.0.0.1 5555 $((RANDOM%4+1)) & done
```
